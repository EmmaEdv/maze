<html>
	<head>
		<title>Labyrint</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<div id="container">
		<script src="js/three.min.js"></script>
		<script src="js/KeyboardState.js"></script>
		<script src="js/stats.min.js"></script>
		<script src="wallPositions.js"></script>
		<script src="js/CollisionControl.js"></script>
		<script>

			var scene, renderer, camera;
			var group;
			var mesh, sphere, spotLight;
			var mazeSize = 16;
			var clock = new THREE.Clock();
			var keyboard = new KeyboardState();
			var obstacles = [];

			init();
			animate();

	    //Sets up the scene:
			function init(){
				var WIDTH = window.innerWidth; 
				var HEIGHT = window.innerHeight;

				//Renderer
				renderer = new THREE.WebGLRenderer({antialias: true});
		    renderer.setSize( WIDTH, HEIGHT );
		    document.body.appendChild( renderer.domElement );
		    
		    //Create scene
		    scene = new THREE.Scene();
		    
		    //Define a camera
		    camera = new THREE.PerspectiveCamera(
	        35,         			// Field of view
	        WIDTH / HEIGHT,  // Aspect ratio
	        .1,         		// Near
	        10000       	 // Far
		    );

		    camera.position.set(40, 40, 0);
		    var viewDirection = {x:0, y:0, z:0};
		    camera.lookAt( viewDirection );

		    //LIGHT
		    //Ambient light
				//var ambient = new THREE.AmbientLight(0x2f2f2f, 0);
				//scene.add(ambient);

				//Load texture
				var marbleTex = THREE.ImageUtils.loadTexture("texture/marble.jpg");
				var marbleMat = new THREE.MeshPhongMaterial( { map: marbleTex } );
				//Apply texture on both sides
				marbleMat.side = THREE.DoubleSide;

		    //Create plane
		    var planeGeo = new THREE.PlaneGeometry( mazeSize*2, mazeSize*2, 32, 32 );
				var plane = new THREE.Mesh( planeGeo, marbleMat );
				plane.rotation.order = "YXZ";
				plane.rotation.x = Math.PI/2;
				plane.position.set(0,0,0)
				scene.add(plane);

		    //Create fence
		    var geometryRight = new THREE.BoxGeometry( 2*mazeSize+1, objectHeight, 1 );
		    var geometryLeft = new THREE.BoxGeometry( 2*mazeSize-5.5, objectHeight, 1 );
		    var geometryTop = new THREE.BoxGeometry( 1, objectHeight, 2*mazeSize+1);
		    var geometryBottom = new THREE.BoxGeometry( 1, objectHeight, 2*mazeSize-5.55);

		    var fenceMat = new THREE.MeshPhongMaterial( { color: 0x000000 } );
		    
		    var rightFence = new THREE.Mesh(geometryRight, fenceMat);
		    rightFence.position.set(0, objectHeight/2, mazeSize);
		    scene.add(rightFence);

		    var bottomFence = new THREE.Mesh(geometryBottom, fenceMat);
		    bottomFence.position.set(mazeSize, objectHeight/2, -3.12);
		    scene.add(bottomFence);
		    
		    var leftFence = new THREE.Mesh(geometryLeft, fenceMat);
		    leftFence.position.set(3.25, objectHeight/2, -mazeSize);
		    scene.add(leftFence);

		    var topFence = new THREE.Mesh(geometryTop, fenceMat);
		    topFence.position.set(-mazeSize, objectHeight/2, 0);
		    scene.add(topFence);

		    //Add to obstacles, for collision control	
		    obstacles.push(rightFence);
		    obstacles.push(bottomFence);
		    obstacles.push(leftFence);
		    obstacles.push(topFence);
				
				//Add maze walls
		    for(var i=0; i<walls.length; i++){
		    	var geo = new THREE.BoxGeometry(walls[i].geo.x, walls[i].geo.y, walls[i].geo.z);
		    	var wall = new THREE.Mesh(geo, fenceMat);
		    	wall.position.set(walls[i].position.x, walls[i].position.y, walls[i].position.z);
		    	scene.add(wall);
		    	//Add to obstacles, for collision control	
		    	obstacles.push(wall);
		    }

		    //Create sphere
				var aluminumTex = THREE.ImageUtils.loadTexture("./texture/aluminum.jpg");
				var aluminumMat = new THREE.MeshPhongMaterial( { map: aluminumTex } );

		    var sphereGeo = new THREE.SphereGeometry( 1, 32, 32 );
		    sphere = new THREE.Mesh( sphereGeo, aluminumMat );
		    sphere.position.set(15.5, 1, 12.5);
		    sphere.direction = {x: -1, y: 0, z:0};
		    scene.add( sphere );

		    spotLight = new THREE.SpotLight(0xFFFFFF);
		    //spotLight.position.set(0,15,0);
		    //spotLight.position.set(sphere.position.x, sphere.position.y + 10, sphere.position.z);
		    spotLight.target = sphere;
		    spotLight.castShadow = true;
		    scene.add(spotLight);

		    //Set 
		    renderer.setClearColor( 0xdddddd, 1);
		    renderer.render( scene, camera );

		    //ToDo: Instructions
			}

	    function animate(){
				requestAnimationFrame(animate);
				//Render the scene
				renderer.render(scene, camera);
				
				update();
			}

			function update(){
				keyboard.update();
				//Update the light position
				spotLight.position.set(sphere.position.x, sphere.position.y + 8, sphere.position.z);

				var moveDistance = 10 * clock.getDelta(); 
				//When pressing left arrow, move left
				if(keyboard.pressed("left")){
					sphere.direction = {x: 0, y: 0, z: 1};
					collision();
					
					if(sphere.direction.x !== 0 || sphere.direction.z !== 0)
					sphere.translateZ( moveDistance );
				}
				//When pressing right arrow, move right
				if(keyboard.pressed("right")){
					sphere.direction = {x: 0, y: 0, z: -1};
					collision();
					
					if(sphere.direction.x != 0 || sphere.direction.z != 0)
						sphere.translateZ( -moveDistance );
				}
				//When pressing down arrow, move down
				if(keyboard.pressed("down")){
					sphere.direction = {x: 1, y: 0, z: 0};
					collision();
					if(sphere.direction.x != 0 || sphere.direction.z != 0)
						sphere.translateX( moveDistance );
				}
				//When pressing up arrow, move up
				if (keyboard.pressed("up")){
					sphere.direction = {x: -1, y: 0, z: 0};
					collision();
					if(sphere.direction.x != 0 || sphere.direction.z != 0)
						sphere.translateX(  -moveDistance );
				}

				//When goal is reached:
				if(sphere.position.x <= -10.5 && sphere.position.z <= -15){
					//Stoppa kontrollerna, skriv ut text
					console.log("Reached goal");
				}
				//Simple check. Needs improvements. If user trying to go outside the fences, put the sphere back
				if(sphere.position.z <= -18){
					sphere.position.set(-12.5, 1, -15);
				}
				if(sphere.position.x >= 18 || sphere.position.z >= 15.5 || (sphere.position.x > 15.5 && sphere.position.z <= 10)){
					sphere.position.set(15.5, 1, 12.5);
				}
			}

		</script>
	</div>
	</body>
</html>
