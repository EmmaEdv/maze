<html>
	<head>
		<title>Labyrint</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<div id="header">Hallo
		</div>
		<div id="container">
		<script src="js/three.min.js"></script>
		<script src="js/KeyboardState.js"></script>
		<script src="js/stats.min.js"></script>
		<script src="wallPositions.js"></script>
		<script src="js/CollisionControl.js"></script>
		<script>
			var scene, renderer, camera;
			var group;
			var mesh, sphere, spotLight;
			var mazeSize = 16;
			var clock = new THREE.Clock();
			var keyboard = new KeyboardState();
			var obstacles = [];

	    var stop = false;

			init();
			animate();

	    //Sets up the scene:
			function init(){
				var WIDTH = window.innerWidth; 
				var HEIGHT = window.innerHeight;

				//Renderer
				renderer = new THREE.WebGLRenderer({antialias: true});
		    renderer.setSize( WIDTH, HEIGHT );
		    document.body.appendChild( renderer.domElement );
		    
		    //Create scene
		    scene = new THREE.Scene();
		    
		    //Define a camera
		    camera = new THREE.PerspectiveCamera(
	        35,         			// Field of view
	        WIDTH / HEIGHT,  // Aspect ratio
	        .1,         		// Near
	        10000       	 // Far
		    );

		    //camera.position.set( -40, 25, 10 );
		    camera.position.set(40, 40, 0);
		    //camera.position.set( 40, 100,0 );
		    var viewDirection = {x:0, y:0, z:0};
		    camera.lookAt( viewDirection );

		    //LIGHT
		    //Ambient light
				var ambient = new THREE.AmbientLight(0x2f2f2f, 0);
				//scene.add(ambient);

		    //Create plane
		    var planeGeo = new THREE.PlaneGeometry( mazeSize*2, mazeSize*2, 32, 32 );
				var material = new THREE.MeshPhongMaterial( {color: 0xffff00, side: THREE.DoubleSide} );
				var plane = new THREE.Mesh( planeGeo, material );
				plane.rotation.order = "YXZ";
				//plane.rotation.y = Math.PI/4;
				plane.rotation.x = Math.PI/2;
				plane.position.set(0,0,0)
				scene.add(plane);

		    //Create fence
		    var geometryRight = new THREE.BoxGeometry( 2*mazeSize+1, 1, 1 );
		    var geometryLeft = new THREE.BoxGeometry( 2*mazeSize-5.5, 1, 1 );
		    var geometryTop = new THREE.BoxGeometry( 1, 1, 2*mazeSize+1);
		    var geometryBottom = new THREE.BoxGeometry( 1, 1, 2*mazeSize-5.55);

		    //var material = new THREE.MeshLambertMaterial( { color: 0x000000 } );
		    var material = new THREE.MeshPhongMaterial( { color: 0x000000 } );
		    var mazeMaterial = new THREE.MeshPhongMaterial( { color: 0x000000 } );
		    var cube = new THREE.Mesh( geometryRight, material );
		    cube.position.set(0, 0.5, mazeSize);
		    scene.add( cube );

		    var cube2 = new THREE.Mesh( geometryBottom, material );
		    cube2.position.set(mazeSize, 0.5, -3.12);
		    scene.add( cube2 );
		    
		    var cube3 = new THREE.Mesh( geometryLeft, material );
		    cube3.position.set(3.25, 0.5, -mazeSize);
		    scene.add( cube3 );

		    var cube4 = new THREE.Mesh( geometryTop, material );
		    cube4.position.set(-mazeSize, 0.5, 0);
		    scene.add( cube4 );

		    //Add to obstacles, for collision control	
		    obstacles.push(cube);
		    obstacles.push(cube2);
		    obstacles.push(cube3);
		    obstacles.push(cube4);
				
				//Add maze walls
		    for(var i=0; i<walls.length; i++){
		    	var geo = new THREE.BoxGeometry(walls[i].geo.x, walls[i].geo.y, walls[i].geo.z);
		    	var wall = new THREE.Mesh(geo, mazeMaterial);
		    	wall.position.set(walls[i].position.x, walls[i].position.y, walls[i].position.z);
		    	scene.add(wall);
		    	//Add to obstacles, for collision control	
		    	obstacles.push(wall);
		    }

		    //Create sphere
		    var sphereGeo = new THREE.SphereGeometry( 1, 32, 32 );
				var material5 = new THREE.MeshPhongMaterial( { color: 0x00FFFF } );
		    sphere = new THREE.Mesh( sphereGeo, material5 );
		    sphere.position.set(15.5, 0.5, 12.5);
		    sphere.direction = {x: -1, y: 0, z:0};
		    scene.add( sphere );

		    spotLight = new THREE.SpotLight(0x00FFFF);
		    //spotLight.position.set(0,15,0);
		    //spotLight.position.set(sphere.position.x, sphere.position.y + 10, sphere.position.z);
		    spotLight.target = sphere;
		    spotLight.castShadow = true;
		    scene.add(spotLight);


		    //Set 
		    renderer.setClearColor( 0xdddddd, 1);
		    renderer.render( scene, camera );

		    //Skapa instruktioner
			}

	    function animate(){
				requestAnimationFrame(animate);

				//Render the scene
				renderer.render(scene, camera);
				
				update();
			}

			function update(){
				keyboard.update();
				//Update the light position
				spotLight.position.set(sphere.position.x, sphere.position.y + 10, sphere.position.z);

				var moveDistance = 10 * clock.getDelta(); 

				if (keyboard.pressed("left")){// && sphere.position.z < mazeSize-2){ 
					sphere.direction = {x: 0, y: 0, z: 1};
					collision();
					if(sphere.direction.x !== 0 || sphere.direction.z !== 0)
						sphere.translateZ( moveDistance );
				}
				if (keyboard.pressed("right")){//&& sphere.position.z > -mazeSize+2){ 
					sphere.direction = {x: 0, y: 0, z: -1};
					collision();
					if(sphere.direction.x != 0 || sphere.direction.z != 0)
						sphere.translateZ( -moveDistance );
				}
				if (keyboard.pressed("down")){// && sphere.position.x < mazeSize-2){ 
					sphere.direction = {x: 1, y: 0, z: 0};
					collision();
					if(sphere.direction.x != 0 || sphere.direction.z != 0)
						sphere.translateX( moveDistance );
				}
					
				if (keyboard.pressed("up")){// && sphere.position.x > -mazeSize+2){ 
					sphere.direction = {x: -1, y: 0, z: 0};
					collision();
					if(sphere.direction.x != 0 || sphere.direction.z != 0)
						sphere.translateX(  -moveDistance );
				}

				if ( keyboard.down("R") ){
					sphere.material.color = new THREE.Color(0xff0000);
				}
				if ( keyboard.up("R") ){
					sphere.material.color = new THREE.Color(0x00FFFF);
				}
				if(sphere.position.x <= -10.5 && sphere.position.z <= -15){
					//Stoppa kontrollerna, skriv ut text
					console.log("MÃ…L!", sphere.position);
				}
				if(sphere.position.z <= -18){
					//Stoppa kontrollerna, skriv ut text
					console.log("STOPP!!!");
					sphere.position.set(-12.5, 0.5, -15);
				}
				if(sphere.position.x >= 18 || sphere.position.z >= 15.5 || (sphere.position.x > 15.5 && sphere.position.z <= 10)){
					//Stoppa kontrollerna, skriv ut text
					console.log("STOPP!!!", sphere.position);
					sphere.position.set(15.5, 0.5, 12.5);
				}
			}

		</script>
	</div>
	</body>
</html>